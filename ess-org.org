* using ESS with Emacs Org mode
** meta : setupt                                                   :noexport:
#+property: header-args :noweb yes
#+property: header-args:org :exports both
#+options: num:0 toc:2
# in this document, i sometimes need sub-, super-scripts, sometimes
# just a caret
#+options: ^:{}
#+property: header-args :noweb yes :exports code :eval never-export :unnumbered non-nil
#+author: Greg Minshall
#+title: using ESS with Emacs Org mode
# floating TOC:
# https://stackoverflow.com/questions/12232675/how-to-make-table-of-contents-floating
# trick of setupfile trick: https://stackoverflow.com/a/56407596/1527747
#+SETUPFILE: ./artefacts/ess-org-startup.org
# LaTeX settings
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [36pt]
# LaTeX [[https://www.ctan.org/pkg/geometry]["geometry" package]], for setting page layout geometry. 
# "showframe" option is nice for debugging.
#+LATEX_HEADER: \usepackage[a4paper, width=.7\paperwidth, height=.8\paperheight]{geometry}

** intro to org mode
basics: document structuring, tables, math/LaTeX, exporting

[[https://www.gnu.org/software/emacs/][Emacs]] ([[https://en.wikipedia.org/wiki/Emacs][wikipedia]]) [[https://orgmode.org/][org mode]] [fn::a.k.a., "org-mode", Org Mode, orgmode
-- the proliferation of notation makes googling somewhat of a
challenge.]  sometimes exhorts one to do something like "Organize Your
Life In Plain Text!"; the org mode manual, on the other hand, starts
off by saying, "Org is an outliner".  the philosophy of org-mode
(indeed, of Emacs, and maybe, to some extent, of any of the *nix
operating systems) is that using non-proprietary file formats and
software provides the most "liberating" and "horizon-free" way of
taking advantage of modern information technology.  and, to some
extent, that a mostly-command line interface, rather than a graphical
user interface, is also "the way to go".

i think org mode started off as a way of simplifying the creation of
formatted documents, with tables, etc., for taking notes, creating
agendas (items with date elements), and evolved into a much larger
system of utilities for, for example, converting ("exporting", in org
mode parlance) between the org mode syntax to .html, .pdf, etc.,
documents, with good support for doing mathematical (LaTeX)
formatting.

a .org file is structured like an outline, with outline sections and
levels indicated by lines starting with one or more asterisks in the
first column; these define "headlines" for the outline.  between
headlines one can include text, tables, bits of code, etc.  bits of
the .org file can be displayed and/or hidden by positioning the cursor
on a headline and (possibly repeatedly) hitting =tab=.

asterisk-defined headlines can include "tags" (=:essintro:=; i am
ignorant of their use), and can optionally be (immediately) followed
by a special "drawer" [fn::a structure starting with an more-or-less
arbitrary name, surrouned by colons, and ending with =:END:=] named
=:PROPERTIES:= holding, well, properties, i.e, (key, value) tuples.

Org mode text markup allows the use of *asterisks*, =equal signs=,
~tildes~, /[forward] slashes/, _underscores_ and (though, apparently,
deprecated) +plus signs+, to achieve different font characteristics.
(until writing this, i have always used equal signs for short bits of
code, but now i will try to remember to try out tildes.)  in-line math
formatting =\(x = cos(y)\)= is supported; Org mode also allows super-
(10^{9}) and subscripts (I_{e}) (though these [[https://stackoverflow.com/a/698791/1527747][can be disabled]], if
desired).

various sorts of "blocks" are supported in org mode files.  these
typically start with =#begin_...=, and end with a corresponding
=#end_...=, where the =...= are something like =src=, =example=,
=quote=.  a skeleton for one of these can conveniently be created by,
in column 1 of an otherwise empty line, typing =<X= followed by =tab=,
where =X= is one of
- =s= for a source block
- =q= for a quote block (line wrapping applies)
- =e= for an example block (line wrapping does not apply)

there are various other blocks; you can experiment by typing (in
column one, of an otherwise empty line) =<= and then one of the
following, and hitting =tab=:
: a, c, C, E, h, l, v
seeing what you get, looking in the manual.  (of course, one can
always search the manual for =#[+]begin_=.)
  
org mode does a good job exporting to LaTeX, html.  (some people
primarily use org mode as a more "user friendly" interface to LaTeX,
though for serious documents, in the final analysis they probably
spend a lot of time tweaking LaTeX, and org-to-LaTeX, configuration.)

in addition to the source blocks mentioned above (and elaborated on
below), org mode allows short bits of "verbatim" code to be introduced
by a colon as the first non-blank column of a line
#+BEGIN_SRC org
  : this is verbatim
#+END_SRC

one can have longer runs of verbatim ("example") data (which is not
word wrapped, etc.:
#+BEGIN_SRC org
  ,#+name: ex
  ,#+begin_example
  this is a block
  that
  holds more verbatim text
  ,#+end_example

  ,#+begin_src R :var foo=ex :exports both
  foo
  ,#+end_src

  ,#+RESULTS:
  | this is a block          |
  | that                     |
  | holds more verbatim text |
  |                          |

  ,#+begin_src R :var foo=ex :exports code
  foo
  ,#+end_src

  ,#+RESULTS:
  | this is a block          |
  | that                     |
  | holds more verbatim text |
  |                          |

#+END_SRC

as well as longer bits of text that *will* be wrapped ("quote"):
#+BEGIN_SRC org
  ,#+begin_quote
  this is a bit of
  text that should
  show up, eventually, strung out in a smaller
  number
  of
  lines when "filled"
  (e.g., [M-x org-fill-paragraph], [M-q])
  ,#+end_quote
#+END_SRC

blocks can optionally have [[naming][names]].  these names can be used as [[noweb][noweb]]
references, or to use the value of a block (or, if a source block, of
the block's results) as input (a [[variables][variable]]) to another block in the
file.[fn::i believe there are facilities for "naming" bits of
information in other .org files, but i don't know the details and i
don't know if it works with source code blocks.]

though i have used org mode for more than a decade, i know very little
of most of its capabilities, as i mostly use it to centralize the
source code within a project, as well as to produce the random
document, especially documents with embedded code segments (known, in
org mode, as "source blocks").  a good source for further information,
in addition to the main [[https://orgmode.org/][org mode]] web page, is the org mode [[https://orgmode.org/worg/][worg]] site.
also, once installed on your system, the org mode info pages are
available in emacs (or, using the info).

org mode is bundled into the main emacs distribution, but a
more-than-casual user might like to use the more-than-likely
up-to-date package available via [[https://melpa.org/][melpa]] (in emacs, use =[M-x
package-list-packages]=, and regexp-search for /^..org /).

** babel -- programming language support in org files

[[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel]] is one name for talking about programming language support in
org mode.  you are able to embed source code inside of org mode
buffers, edit these code blocks in a language-specific way, evaluate
code blocks, pass the results of the evaulation of one code block to
another code block, and include code blocks and/or the results of
their evaulation in the document produced by exporting the org buffer.

*** <<sourceblocks>> source blocks

Org mode source blocks look like this
#+BEGIN_SRC org
  ,#+begin_src R
	  "hello, world!"
  ,#+end_src

  ,#+RESULTS:
  : hello, world!
#+END_SRC

(as mentioned above, a source block skeleton can be created by
typing, in column 1, =<s=, and hitting =tab=.)

Org mode source blocks can be edited, either inline in the org mode
(".org") document buffer, or in a separate buffer (i call these "Org
Src..." buffers, but they might also be known as "sub-edit buffers" or
"source edit buffers) that you can "pop up" from the .org buffer ("pop
out of the .org buffer"?), normally with =[C-c ']=.  in the latter,
there is better support for emacs so-called "font locks", which do
program language-specific source code highlighting, etc.

once written, a source block can be evaulated[fn:: for security
  reasons, you will need to set or customize the Emacs variable
  =org-babel-load-languages= , via =org-babel-do-load-languages= if
  you are doing this to in a current emacs session, and you will be
  prompted each time before a code block is evaluated.], returning
  [[results][results]], either the output of the code, or some terminating "value"
  of the code, as an element of the .org file.  and, the blocks can be
  evaulated manually, or -- and optionally, block by block -- while
  exporting a .org file to a different format.

a source block can be evaulated in one of two sorts of contexts, within
a "session", or outside of a "session".  a "session" here means some
process that retains state between evaulations of (possibly different)
source blocks.  on the other hand, a "non-session" starts up with no
internal [fn::obviously, prior runs may have, e.g., changed the state
of the file system on which all these evaulations are running; that is,
the *external* state may by influenced by what has previously been
evaulated.] state from prior runs.

source blocks can also be expressed using a =src_LANG= construct; a
=#+name:= line can be used to name the =src_LANG= block.

#+BEGIN_SRC org
  ,#+name: whyo
  src_R{"42"} {{{results(=42=)}}}

  ,#+begin_src R :var x=whyo :exports results
  x
  ,#+end_src

  ,#+RESULTS:
  | 42 |
  |    |

#+END_SRC

finally, and of particular interest in these tutorials, is the fact
that org mode uses ESS to provide R language support.

   [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-R.html][worg page]] on R and org-mode.

*** <<naming>> naming blocks

there are two ways of naming blocks.  first, an individual block
itself can be preceded by a =#+name:= line
#+BEGIN_SRC org
  ,#+name: somecode
  ,#+begin_src R :results output
	  cat("this is *some* code!\n")
  ,#+end_src

  ,#+RESULTS: somecode
  : this is *some* code!

  ,#+name: someothercode
  ,#+begin_src R :results value
	  whynot <- "this is some *other* code!"
  ,#+end_src

  ,#+RESULTS: someothercode
  : this is some *other* code!

#+END_SRC

<<properties>> second, a PROPERIES drawer, using the =header-args=
attribute =noweb-ref= to name the (otherwise unnamed, i believe) code
blocks in that branch.
#+BEGIN_SRC org
  ,#+property: header-args :noweb yes

  ,** this is somewhere in this file
	   :PROPERTIES:
	   :header-args+: :tangle very/important/code.R
	   :header-args+: :noweb-ref nowcode
	   :END:

  now, code blocks will carry that name
  ,#+begin_src R
	  x <- "we want some code, and we want it now!"
  ,#+end_src

  ,#+RESULTS:
  : we want some code, and we want it now!

  ,** somewhere else
  ,#+begin_src R :results output
	  <<nowcode>>
	  cat(x, "\n")
  ,#+end_src

  ,#+RESULTS:
  : we want some code, and we want it now! 
#+END_SRC

as you can see, the properties drawer can carry many of properties,
including the name of a destination file for [[tangling][tangling]].  the very odd
=<<nowcode>>= is our next topic: [[noweb][noweb]].

*** <<noweb>> noweb

[[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming-example][noweb]] is a literate programming syntax to allow referencing blocks of
code within some larger (.org file, say) context.  it allows a
programmer to re-use bits of code (sort of =#include= like).

noweb syntax is *disabled* by default.  to enable noweb syntax, one
can either enable it on the header line of each source code block,
enable it in a properties drawer, or, as in the following, enable it
once at the beginning of an org file:
#+BEGIN_SRC org
  ,#+property: header-args  :noweb yes
#+END_SRC

once enabled, references of the kind =<<NAME>>= will incorporate the
contents of a previous source code block.

#+BEGIN_SRC org
  ,#+property: header-args :noweb yes

  ,#+name: fubar
  ,#+begin_src R
  "this is an example"
  ,#+end_src

  ,#+RESULTS: fubar
  : this is an example

  ,#+begin_src R
  <<fubar>>
  ,#+end_src

  ,#+RESULTS:
  : this is an example

#+END_SRC

*** <<tangling>> tangling

while often we are content to evaulate code blocks inside the .org
file, equally often we might want to export some or all of the code
blocks for evaulation (or inspection) outside of the .org file.  for
example, we might want to use some of the code in the .org file to
create an R package.

in the world of [[https://orgmode.org/worg/org-contrib/babel/index.html][literate programming]], /tangling/ is the process of
extracting source code from a (theoretically primarily text) document.
in org mode, one uses =org-babel-tangle= (normally bound to =[C-c C-v
t]=) to tangle the source code blocks in a file.  the file to which a
source block will be tangled is specified in the =:tangle= attribute,
placed on the =#+src_block= line or in a =:header-args= line (in a
properties drawer, to apply to a subtree of the .org file, or
stand-alone as above to apply to the entire .org file).

to actually /tangle/ a file, use =]M-x org-babel-tangle]=, often bound
to =[C-c C-v t]=.
   
*** <<evaulating>> evaulating
**** =[C-c C-c]= on a source block
**** =[C-c C-c]= on an inline source block
**** =[C-c C-c]= on a #+call
**** =[C-c C-c]= on an inline-call
#+begin_src org
  ,#+name: find-orgs
  ,#+begin_src R
  1
  ,#+end_src

  ,#+RESULTS: find-orgs
  : 1

  call_find-orgs() {{{results(=1=)}}}

  ,#+call: find-orgs()

  ,#+RESULTS:
  : 1

  call_find-orgs() {{{results(=1=)}}}

#+end_src
**** :colnames and :rownames
#+begin_src org
  ,#+BEGIN_SRC R
  mtcars[1:3,]
  ,#+END_SRC

  ,#+RESULTS:
  |   21 | 6 | 160 | 110 |  3.9 |  2.62 | 16.46 | 0 | 1 | 4 | 4 |
  |   21 | 6 | 160 | 110 |  3.9 | 2.875 | 17.02 | 0 | 1 | 4 | 4 |
  | 22.8 | 4 | 108 |  93 | 3.85 |  2.32 | 18.61 | 1 | 1 | 4 | 1 |

  ,#+begin_src R :colnames yes :rownames yes
  mtcars[1:3,]
  ,#+end_src

  ,#+RESULTS:
  |               |  mpg | cyl | disp |  hp | drat |    wt |  qsec | vs | am | gear | carb |
  |---------------+------+-----+------+-----+------+-------+-------+----+----+------+------|
  | Mazda RX4     |   21 |   6 |  160 | 110 |  3.9 |  2.62 | 16.46 |  0 |  1 |    4 |    4 |
  | Mazda RX4 Wag |   21 |   6 |  160 | 110 |  3.9 | 2.875 | 17.02 |  0 |  1 |    4 |    4 |
  | Datsun 710    | 22.8 |   4 |  108 |  93 | 3.85 |  2.32 | 18.61 |  1 |  1 |    4 |    1 |

#+end_src

*** <<results>> results

#+BEGIN_SRC org
  ,#+name: somecode
  ,#+begin_src R :results output
	  cat("this is *some* code!\n")
  ,#+end_src

  ,#+RESULTS: somecode
  : this is *some* code!

  ,#+name: someothercode
  ,#+begin_src R :results value
	  whynot <- "this is some *other* code!"
  ,#+end_src

  ,#+RESULTS: someothercode
  : this is some *other* code!

#+END_SRC

*** <<variables>> variables
-- in and out
entire document or a subtree of the document
*** life in Org Src buffers
*** <<exporting>> exporting

** org-mode community

   mailing lists

** other tutorials, etc.

[[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][Rainer's screencasts about Org mode]] (now a [[https://www.udemy.com/course/getting-yourself-organized-with-org-mode/?referralCode=D0CB0D077ED5EC0788F7][course on Udemy]])

[[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][tutorial on R and org-mode]]
#+begin_example
From: Erik Iverson <erikriverson@gmail.com>
Date: Tue, 23 Feb 2021 12:30:03 -0800
Subject: Re: org-in-org
To: Greg Minshall <minshall@umich.edu>
Cc: emacs-orgmode <emacs-orgmode@gnu.org>
#+end_example

https://raw.githubusercontent.com/vikasrawal/orgpaper/master/orgpapers.org
or
https://github.com/vikasrawal/orgpaper/blob/master/orgpapers.org
or, more recently:
#+begin_example
From: Jeremie Juste <jeremiejuste@gmail.com>
To: Greg Minshall <minshall@umich.edu>
Subject: Re: org-in-org
Date: Tue, 23 Feb 2021 22:38:06 +0100
Cc: emacs-orgmode@gnu.org
#+end_example

** experiments                                                      :noexport:

*** audio problems
trying to get microphone to work.  used [[https://wiki.archlinux.org/index.php/PulseAudio/Troubleshooting#Microphone_not_detected_by_PulseAudio][arch pulseaudio
troubleshooting]] page.  "PulseAudio uses wrong microphone" seemed to do
it, with alsamixer:
- F6
- choose actual hardware
- F5 (i used F4)
- select "Capture" ("input source" i didn't see)
then seemed to work, but was overmodulating.  used alsamixer, lowered
level.  (took a couple of times to take effect?)

also
: pactl list sources short
: arecord -l
: pavucontrol
(click on "Input Devices", see that the other microphones -- Front,
Headset -- are unplugged, only Internal is plugged in.

*** more
#+NAME: readdata-code
#+BEGIN_SRC org

  ,#+NAME: readdata-code
  ,#+BEGIN_SRC R :results value silent

  read.data("datafile1.csv",sep=",",header=T)->mydata1


  ,#+END_SRC
#+END_SRC

#+BEGIN_SRC org
  ,#+begin_src R
	  print("abc")
  ,#+end_src

  ,#+RESULTS:
  : abc

#+END_SRC


#+BEGIN_SRC org
  ,#+begin_src R
	  print("def")
  ,#+end_src

  ,#+RESULTS:
  : def
#+END_SRC

** code blocks

there are a few pieces of information org-mode needs to define a
block of code
- (optionally) a =name= for the block (to use to include the block's
  code in another block with [[file:ess-org.org::*<<noweb>> noweb][noweb]], or to use the block's results as
  input to another block with [[file:ess-org.org::*<<variables>> variables][:var]].
- the language of the code in the block
- various arguments (=header arguments= and =switches=) that define
  how the code interacts with its environment
- the source code itself

there are at least two ways of encoding the needed information:

*** a source block

the most "normal" way of defining source code is with a /source
block/.

#+begin_src org
  ,#+begin_src R
    "hello, world"
  ,#+end_src

  ,#+RESULTS:
  : hello, world
#+end_src

we use this form below in discussing the structure of a code block.

*** an /inline/ code block

in a second form, known as an /inline code block/, the entire block
can fit on one line (though multiple lines are possible).

#+begin_src org
  src_R{"hello, world"} {{{results(=hello\, world=)}}}
#+end_src

i don't use this form.  for this tutorial i looked at it briefly.  it
appears its semantics are different from that of source blocks.  other
than that, i will not discuss it further.

*** the anatomy of a source block

#+begin_src org
  ,#+name: refid
  ,#+begin_example
  this is a test
  ,#+end_example

  ,#+name: anatomy
  ,#+begin_src R :var varname=refid :results output
  cat(varname)
  ,#+end_src

  ,#+RESULTS: anatomy
  : this is a test

  ,#+header: :var anothername=anatomy
  ,#+header: :exports results
  ,#+header: :results value
  ,#+name: second
  ,#+begin_src R
  anothername
  ,#+end_src

  ,#+RESULTS: second
  | this is a test |
  |                |
#+end_src

the block named /refid/ is not a code block, but shows how the
contents of another block (verbatim, in this case) can be used as
input to a code block.

we set /anatomy/ as the name of the first code block, using the
=#+name= line.

then, we declare /anatomy's/ source block with the =#+begin_src= line,
which has
- the language (=R=, of course)
- a header argument specifying an input variable named /varname/,
  using the value of /refid/ block
- another header argument specifying that the result of this block
  will be taken from whatever it prints on stdout

the code for /anatomy/ just consists of printing the (input) variable
/varname/ to stdout.

we continue by defining yet another source block, which we name
/second/.  it shows a different way of specifying the header
arguments, via =#+header= lines, each of which can define one or more
header arguments.  one can put some header arguments on the
=#+begin_src= line, some on one or or more =#+header= lines.

- :exports code
- :results table
- :colnames yes
- :exports none
- :tangle no
- :results none
- :var csvsedtable=csvsedtable
- :results output verbatim
- :cache

** meta : tools, etc                                                :noexport:

https://obsproject.com/wiki/OBS-Studio-Quickstart obs, on arch linux
(part of the obs-studio package).

https://github.com/ess-intro/ess-intro/issues is where most discussion
happens.

[[https://emacsconf.org/2020/talks/30/][vterm]] is pretty fast.

to get little modifier key thing:
: pip install git+https://github.com/scottkirkwood/key-mon
but, it doesn't like my control key.

to evaluate each code block in a buffer:
:from:
#+begin_example
From: "Berry, Charles" <ccberry@health.ucsd.edu>
To: Greg Minshall <minshall@umich.edu>
CC: "emacs-orgmode@gnu.org" <emacs-orgmode@gnu.org>
Subject: Re: org-in-org
Date: Tue, 23 Feb 2021 19:46:32 +0000
#+end_example
:end:
#+header: :results both
#+BEGIN_SRC emacs-lisp
(defun org-exe-org ()
  (let ((org-confirm-babel-evaluate nil))
    (org-edit-src-code)
    (org-babel-execute-buffer)
    (org-edit-src-exit)))
#+END_SRC
then, do this:
: (org-babel-map-executables nil (org-exe-org))

but, i'd rather query, e.g., =:exports= to see if it exports results.

** elisp code                                                       :noexport:
       :PROPERTIES:
       :header-args+: :tangle ./tangled/el-org.el
       :END:

#+name: org-filter-by-results
#+begin_src elisp :results none
  (require 'ob-core)

  (defun org-filter-by-argument-value (arg values &optional locs negate)
	  "Return the subset of LOCS (default: (point)) that correspond
  to evaulatable locations in the current buffer whose
  \"info\" (org-babel-get-src-block-info) argument parameter
  contains an argument ARG with a value in VALUES."
	  (let ((pt (point))
				  (results (mapcar (lambda (l)
									   (progn
										   (goto-char l)
										   (let* ((info (org-babel-get-src-block-info))
														  (value (cdr (assoc arg (nth 2 info)))))
											   (if (or (and negate (not (member value values)))
															   (and (not negate) (member value values)))
													   l
												   nil))))
								   (if locs locs (list (point))))))
		(goto-char pt)
		(reverse (seq-filter (lambda(x) x) results))))
#+end_src

*** for each block in the (whichever) buffer

- if ":exports code/both", create a systematically-named file with the
  code
- if ":exports results/both", create a systematically-named file with
  the results

		"visit each code block in the current buffer.  if the block
	should export code, build a separate file with that code.  if the
	block should export results, evaluate the code block and place
	the results in a separate file.  the separate files names are
	derived from the name of the source code block, with either
	\"code\" or \"results\" appended, and is added to directory
	DIR (default: \"./EXPORTS\").  if a source block is unnamed, its
	[zero-based] ordinal position in the file is use (prefixed by the
	string \"N-\")."

*** for each block in the (whichever) buffer

- if :eval is not (some form of) "no", offer it up for evaluation

#+name: org-walk-and-evaulate
#+BEGIN_SRC elisp :results none
  (require 'ob-core)

  (defun org-walk-and-evaulate (&optional arg)
	  "Based on org-babel-execute-buffer, with the main difference
  that we return the locations of the blocks we evaulated.  Probably
  should just use o-b-e-b."
	  (let ((result nil))
		  (save-window-excursion
			  (org-babel-map-executables nil
				  (if (org-filter-by-argument-value
						   ':eval
						   (list "never" "never-export" "no" "no-export")
						   nil
						   t)
						  (progn
							  ;; fine, this is horrible.
							  (setq result (append result (list (point))))
							  ;; flat-out copied from (org-babel-execute-buffer)
							  (if (memq (org-element-type (org-element-context))
												  '(babel-call inline-babel-call))
									  (org-babel-lob-execute-maybe)
								  (org-babel-execute-src-block arg))
							  (point)))))
		  result))
#+END_SRC

*** for each org block in the (whichever) buffer

- if :exports "results" or "both", evaulate all blocks in the org block

#+name: org-get-org-blocks
#+begin_src elisp :results none
  (require 'ob-core)
  (require 'org-element)

  (defun org-get-org-blocks ()
    "return the starting location of each org (language) source
  block in the current buffer"
    (let ((blocks nil))
      (org-babel-map-executables nil
        (let ((info (org-babel-get-src-block-info t)))
          (if (equal (car info) "org")
              (setq blocks (cons (point) blocks)))))
      (reverse blocks)))
#+end_src

for each org-in-org block that :exports either "results" or "both",
open up an edit buffer, and evaulate all internal code that :exports
either "results" or "both".
#+name: main-loop
#+begin_src elisp :results none
	(defun do-org-blocks ()
		(let (results
					(pt (point)))
			(org-babel-eval-wipe-error-buffer)
			(unwind-protect
					(save-window-excursion
						(mapc
						 (lambda (l)
							 (goto-char l)
							 (org-babel-do-in-edit-buffer
								(let ((result (org-walk-and-evaulate)))
									(org-edit-src-save)
									(setq results (append results (list (list l result)))))))
						 (org-filter-by-argument-value
							':exports (list "results" "both") (org-get-org-blocks))))
				(goto-char pt))
			results))
#+end_src

#+name: publishing
#+begin_src elisp :results none
  (setq org-publish-project-alist
        '(("ess-org-html"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org.org")
           :publishing-function org-html-publish-to-html)
          ("ess-org-pdf"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org.org")
           :publishing-function org-latex-publish-to-pdf)
          ("ess-org-beamer-pdf"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org-beamer.org")
           :publishing-function org-beamer-publish-to-pdf)
          ("ess-org" :components ("ess-org-html" "ess-org-pdf" "ess-org-beamer-pdf"))))
#+end_src

** css                                                              :noexport:

#+begin_src css :tangle ./tangled/floattoc.css
  #table-of-contents {
        position: fixed;
        right: 0;
        top: 0;
        background-color:#FFF;
        padding: 1px 1%;
        border: 1px solid rgb(201,44,44);
        z-index: 2; /**/
  }

  /* Hide the full TOC by default */
  #table-of-contents #text-table-of-contents { display: none; }

  #table-of-contents:hover #text-table-of-contents {
        display: block; /* Show it on hover */
  }
#+end_src

