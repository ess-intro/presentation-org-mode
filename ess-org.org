* using ESS with Emacs Org Mode
** meta : setup                                                    :noexport:
#+author: Greg Minshall
# XXX can't use title with ggm-twbs: #+title: using ESS with Emacs Org Mode
#+subtitle: part of the ESS intro series
#+property: header-args :noweb yes
#+property: header-args:org :exports both
#+options: num:0 toc:2
# in this document, i sometimes need sub-, super-scripts, sometimes
# just a caret
#+options: ^:{}
#+property: header-args :noweb yes :exports code :eval never-export :unnumbered non-nil
# floating TOC:
# https://stackoverflow.com/questions/12232675/how-to-make-table-of-contents-floating
# trick of setupfile trick: https://stackoverflow.com/a/56407596/1527747
#+SETUPFILE: ./artefacts/ess-org-startup.org
# LaTeX settings
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [36pt]
# LaTeX [[https://www.ctan.org/pkg/geometry]["geometry" package]], for setting page layout geometry. 
# "showframe" option is nice for debugging.
#+LATEX_HEADER: \usepackage[a4paper, width=.7\paperwidth, height=.8\paperheight]{geometry}

** Introduction to Org Mode
basics: document structuring, tables, math/LaTeX, exporting

[[https://www.gnu.org/software/emacs/][Emacs]] ([[https://en.wikipedia.org/wiki/Emacs][wikipedia]]) [[https://orgmode.org/][Org Mode]] [fn::a.k.a., "org-mode", Org Mode, orgmode
-- the proliferation of notation makes googling somewhat of a
challenge.]  sometimes exhorts one to do something like "Organize Your
Life In Plain Text!"; the Org Mode manual, on the other hand, starts
off by saying, "Org is an outliner".  The philosophy of Org Mode
(indeed, of Emacs, and maybe, to some extent, of any of the *nix
operating systems) is that using non-proprietary file formats and
software provides the most "liberating" and "horizon-free" way of
taking advantage of modern information technology.  And, to some
extent, that a mostly-command line interface, rather than a graphical
user interface, is also "the way to go".

I think Org Mode started off as a way of simplifying the creation of
formatted documents, with tables, etc., for taking notes, creating
agendas (items with date elements), and evolved into a much larger
system of utilities for, for example, converting ("exporting", in org
mode parlance) between the Org Mode syntax to .html, .pdf, etc.,
documents, with good support for doing mathematical (LaTeX)
formatting.

Org Mode does a good job exporting to LaTeX, html.  (Some people
primarily use Org Mode as a more "user friendly" interface to LaTeX,
though for serious documents, in the final analysis they probably
spend a lot of time tweaking LaTeX, and org-to-LaTeX, configuration.)

Though I have used Org Mode for more than a decade, I know very little
of most of its capabilities, as I mostly use it to centralize the
source code within a project, as well as to produce the random
document, especially documents with embedded code segments (known, in
Org Mode, as "source blocks").

Org Mode is bundled into the main Emacs distribution, but a
more-than-casual user might like to use the more-than-likely
up-to-date package available via [[https://melpa.org/][melpa]] (=[M-x package-list-packages]=,
and regexp-search for /^..org /).

The official [[https://orgmode.org/quickstart.html][Quick Start]] guide provides a very good introduction to
Org Mode.  The main [[https://orgmode.org/][Org Mode]] web page is another good source for
further information, as is the Org Mode [[https://orgmode.org/worg/][worg]] site.  (You may find it
useful to take a linear stroll through [[https://orgmode.org/worg/sitemap.html][the worg site map]].)  Also, once
installed on your system, the Org Mode info pages are available in
Emacs (or, using =info(1)=).


*** Blocks of various sizes, shapes, colors

Various sorts of "blocks" are supported in Org Mode files.  These
start with =#begin_...=, and end with a corresponding =#end_...=,
where the =...= are something like =src=, =example=, =quote=.  A
skeleton for some of these can conveniently be created by, in column 1
of an otherwise empty line, typing =[<X]= followed by =[tab]=, where
=X= is one of
- =e= for an example block (line wrapping does not apply) (=#+begin_example=)
- =q= for a quote block (line wrapping applies) (=#+begin_quote=)
- =s= for a source block (=#+begin_src=)

there are various other blocks; you can experiment by typing (in
column one, of an otherwise empty line) =[<]= and then one of the
following, and hitting =[tab]=:
: a, c, C, E, h, l, v
seeing what you get, looking in the manual.  (Of course, one can
always search the manual for =#[+]begin_=.)
  
In addition to the source blocks mentioned above (and elaborated on
below), Org Mode allows short bits of "verbatim" code to be introduced
by a colon as the first non-blank column of a line
#+BEGIN_SRC org
  : this is verbatim
#+END_SRC

One can have longer runs of verbatim ("example") data (which is not
word wrapped, etc.:
#+BEGIN_SRC org
  ,#+name: ex
  ,#+begin_example
  this is a block
  that
  holds more verbatim text
  ,#+end_example
#+END_SRC

As well as longer bits of text that *will* be wrapped ("quote"):
#+BEGIN_SRC org
  ,#+begin_quote
  this is a bit of
  text that should
  show up, eventually, strung out in a smaller
  number
  of
  lines when "filled"
  (e.g., [M-x org-fill-paragraph], [M-q])
  ,#+end_quote
#+END_SRC

Blocks can optionally have [[naming][names]].  These names can be used as [[noweb][noweb]]
references, or to use the value of a block (or, if a source block, of
the block's results) as input (a [[variables][variable]]) to another block in the
file.[fn::I believe there are facilities for "naming" bits of
information in other .org files, but I don't know the details and I
don't know if it works with source code blocks.]

** Babel -- programming language support in org files

[[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel]] is one name for talking about programming language support in
Org Mode.  You are able to embed source code inside of Org Mode
buffers, edit these code blocks in a language-specific way, evaluate
code blocks, pass the results of the evaulation of one code block to
another code block, and include code blocks and/or the results of
their evaulation in the document produced by exporting the org buffer.

** Org Mode community

   mailing lists

** Other tutorials, etc.

The Org Mode [[https://orgmode.org/guide/][Compact Guide]] has [[https://orgmode.org/guide/Working-with-Source-Code.html][a section]] on source blocks.  A separate
[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-R.html]["worg" page]] gives information on using R with Org Mode.  The list of
languages officially supported by Org Mode is documented [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][here]].  In
addition to that list, a number of Emacs [[https://www.emacswiki.org/emacs/InstallingPackages][packages]] add support for
additional programming languages; you can enter =[M-x list-packages]=
and (regexp) search for =^ ob-=, to list a number of these.

The Org Mode [[https://orgmode.org/quickstart.html][quickstart]] is a nice way to start with Org Mode.

[[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][Rainer's screencasts about Org Mode]] (now a [[https://www.udemy.com/course/getting-yourself-organized-with-org-mode/?referralCode=D0CB0D077ED5EC0788F7][course on Udemy]])

[[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][tutorial on R and Org Mode]]
#+begin_example
From: Erik Iverson <erikriverson@gmail.com>
Date: Tue, 23 Feb 2021 12:30:03 -0800
Subject: Re: org-in-org
To: Greg Minshall <minshall@umich.edu>
Cc: emacs-orgmode <emacs-orgmode@gnu.org>
#+end_example

https://raw.githubusercontent.com/vikasrawal/orgpaper/master/orgpapers.org
or
https://github.com/vikasrawal/orgpaper/blob/master/orgpapers.org
or, more recently:
#+begin_example
From: Jeremie Juste <jeremiejuste@gmail.com>
To: Greg Minshall <minshall@umich.edu>
Subject: Re: org-in-org
Date: Tue, 23 Feb 2021 22:38:06 +0100
Cc: emacs-orgmode@gnu.org
#+end_example

** experiments                                                      :noexport:

*** audio problems
trying to get microphone to work.  used [[https://wiki.archlinux.org/index.php/PulseAudio/Troubleshooting#Microphone_not_detected_by_PulseAudio][arch pulseaudio
troubleshooting]] page.  "PulseAudio uses wrong microphone" seemed to do
it, with alsamixer:
- F6
- choose actual hardware
- F5 (i used F4)
- select "Capture" ("input source" i didn't see)
then seemed to work, but was overmodulating.  used alsamixer, lowered
level.  (took a couple of times to take effect?)

also
: pactl list sources short
: arecord -l
: pavucontrol
(click on "Input Devices", see that the other microphones -- Front,
Headset -- are unplugged, only Internal is plugged in.

*** more
#+NAME: readdata-code
#+BEGIN_SRC org

  ,#+NAME: readdata-code
  ,#+BEGIN_SRC R :results value silent

  read.data("datafile1.csv",sep=",",header=T)->mydata1


  ,#+END_SRC
#+END_SRC

#+BEGIN_SRC org
  ,#+begin_src R
      print("abc")
  ,#+end_src

  ,#+RESULTS:
  : abc

#+END_SRC


#+BEGIN_SRC org
  ,#+begin_src R
      print("def")
  ,#+end_src

  ,#+RESULTS:
  : def
#+END_SRC

** meta : tools, etc                                                :noexport:

https://obsproject.com/wiki/OBS-Studio-Quickstart obs, on arch linux
(part of the obs-studio package).

https://github.com/ess-intro/ess-intro/issues is where most discussion
happens.

[[https://emacsconf.org/2020/talks/30/][vterm]] is pretty fast.

to get little modifier key thing:
: pip install git+https://github.com/scottkirkwood/key-mon
but, it doesn't like my control key.

to evaluate each code block in a buffer:
:from:
#+begin_example
From: "Berry, Charles" <ccberry@health.ucsd.edu>
To: Greg Minshall <minshall@umich.edu>
CC: "emacs-orgmode@gnu.org" <emacs-orgmode@gnu.org>
Subject: Re: org-in-org
Date: Tue, 23 Feb 2021 19:46:32 +0000
#+end_example
:end:
#+header: :results both
#+BEGIN_SRC emacs-lisp
(defun org-exe-org ()
  (let ((org-confirm-babel-evaluate nil))
    (org-edit-src-code)
    (org-babel-execute-buffer)
    (org-edit-src-exit)))
#+END_SRC

then, do this:
: (org-babel-map-executables nil (org-exe-org))

but, i'd rather query, e.g., =:exports= to see if it exports results.

** elisp code                                                       :noexport:
       :PROPERTIES:
       :header-args+: :tangle ./tangled/el-org.el
       :END:

*** org-filter-by-argument-value
#+name: org-filter-by-argument-value
#+begin_src elisp :results none
  (require 'ob-core)

  (defun org-filter-by-argument-value (arg values &optional locs negate)
    "Return the subset of LOCS (default: (point)) that correspond
  to evaluatable locations in the current buffer whose
  \"info\" (org-babel-get-src-block-info) argument parameter
  contains an argument ARG with a value in VALUES."
    (let ((pt (point))
          (results (mapcar (lambda (l)
                             (progn
                               (goto-char l)
                               (let* ((info (org-babel-get-src-block-info t))
                                      (value (cdr (assoc arg (nth 2 info)))))
                                 (if (or
                                      (not info) ; call site? XXX should filter?
                                      (and negate (not (member value values)))
                                      (and (not negate) (member value values)))
                                     l
                                   nil))))
                           (if locs locs (list (point))))))
      (goto-char pt)
      (reverse (seq-filter (lambda(x) x) results))))
#+end_src

*** for each block in the (whichever) buffer

- if :eval is not (some form of) "no", offer it up for evaluation

#+name: org-walk-and-evaluate
#+BEGIN_SRC elisp :results none
  (require 'ob-core)

  (defun org-walk-and-evaluate (&optional arg values dontnegate)
      "Based on org-babel-execute-buffer, with the main difference
  that we return the locations of the blocks we evaluated.  Probably
  should just use o-b-e-b."
      (let ((result nil)
            (arg (if arg arg ':eval))
            (values (if values
                        values
                      (list "never" "never-export" "no" "no-export")))
            (negate (if dontnegate nil t)))
        (save-window-excursion
          (org-babel-map-executables nil
            (if (org-filter-by-argument-value
                 arg values nil negate)
                (progn
                  ;; fine, this is horrible.
                  (setq result (append result (list (point))))
                  ;; flat-out copied from (org-babel-execute-buffer)
                  (if (memq (org-element-type (org-element-context))
                            '(babel-call inline-babel-call))
                      (org-babel-lob-execute-maybe)
                    (org-babel-execute-src-block))
                  (point)))))
        result))
#+END_SRC

*** find all [non-]org blocks

#+name: org-get-org-blocks
#+begin_src elisp :results none
  (require 'ob-core)
  (require 'org-element)

  (defun org-get-org-blocks (&optional complement)
    "return the starting location of each org (language) source
  block in the current buffer; returns the complement of that set
  if COMPLEMENT is true"
    (let ((blocks nil))
      (org-babel-map-executables nil
        (let* ((context (org-element-context))
               (ctype (car context))
               (clist (cadr context)))
          (if (or (memq ctype '(babel-call inline-babel-call))
                  (xor (equal (plist-get clist :language) "org") complement))
              (setq blocks (cons (point) blocks)))))
      (reverse blocks)))
#+end_src

*** orgify all non-org blocks

#+name: orgify-blocks
#+begin_src elisp :results none
  (defun orgify-blocks (locs)
    ;; take each block that starts at a location in LOCS and insert it
    ;; between #+begin_src org...#+end_src
    (let ((to-insert "#+begin_src org :exports code :noweb nil\n#+end_src\n")
          ;; we work on the reversed list, from the end of the buffer to the
          ;; beginning, since our actions are going to change line numbers
          (slocs (sort locs '>)))
      (mapc
       (lambda (l)
         ;; (debug)
         (goto-char l)
         (let* ((context (org-element-context))
                (ctype (car context))
                (clist (cadr context))
                (src-begin (plist-get clist :begin))
                (src-end (plist-get clist :end ))
                (results-begin (org-babel-where-is-src-block-result))
                (results-end (if results-begin
                                 (progn (goto-char results-begin)(org-babel-result-end))
                               nil))
                (begin (progn
                         (goto-char src-begin)
                         (if (member ctype '(inline-src-block inline-babel-call))
                             (progn (org-backward-paragraph) (forward-char)))
                         (point)))
                (end (progn
                       (goto-char (if results-end results-end src-end))
                       (if (member ctype '(inline-src-block inline-babel-call))
                           (progn (org-forward-paragraph) (backward-char)))
                       (re-search-backward "^..*$")
                       (org-forward-paragraph)
                       (backward-char)
                       (point)))
                (contents (delete-and-extract-region begin end)))
           (insert to-insert)
           (goto-char begin)            ; go back to beginning of new src block
           (org-babel-do-in-edit-buffer
            (insert contents)))) ; now, in edit buffer, insert previuos contents
       slocs)))
#+end_src

#+name: orgify-all-non-org-blocks
#+begin_src elisp :results none
  (defun orgify-all-non-org-blocks ()
    ;; take every non-org block, as well as call site, and insert it
    ;; between #+begin_src org...#+end_src
    (let ((pt (point))                    ; XXX s/b marker?
          (filtered (org-get-org-blocks t)))
      (unwind-protect
          (save-window-excursion
            (orgify-blocks filtered))
        (goto-char pt))
    (reverse filtered)))
#+end_src

#+RESULTS: orgify-all-non-org-blocks
: orgify-all-non-org-blocks

*** evaluate all(*) the non-org blocks in the buffer

(*) if :exports "results" or "both", evaluate it

#+name: evaluate-non-org-blocks
#+begin_src elisp :results none
  (defun evaluate-non-org-blocks ()
      (let (results
            (pt (point)))
        (org-babel-eval-wipe-error-buffer)
        (unwind-protect
            (save-window-excursion
              (setq results (org-walk-and-evaluate
                             ':exports
                             (list "results" "both")
                             (org-get-org-blocks t)))))
          results))
#+end_src
*** evaluate (internals of) all(*) the org blocks in the buffer

(*) if :exports "results" or "both", evaluate all blocks in the org block

for each org-in-org block that :exports either "results" or "both",
open up an edit buffer, and evaluate all internal code that :exports
either "results" or "both".

#+name: evaluate-org-blocks
#+begin_src elisp :results none
	(defun evaluate-org-blocks ()
		(let (results
					(pt (point)))
			(org-babel-eval-wipe-error-buffer)
			(unwind-protect
					(save-window-excursion
						(mapc
						 (lambda (l)
							 (goto-char l)
							 (org-babel-do-in-edit-buffer
								(let ((result (org-walk-and-evaluate)))
									(org-edit-src-save)
									(setq results (append results (list (list l result)))))))
						 (org-filter-by-argument-value
							':exports (list "results" "both") (org-get-org-blocks))))
				(goto-char pt))
			results))
#+end_src

#+name: publishing
#+begin_src elisp :results none
  (setq org-publish-project-alist
        '(("ess-org-html"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org.org")
           :publishing-function org-html-publish-to-html)
          ("ess-org-pdf"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org.org")
           :publishing-function org-latex-publish-to-pdf)
          ("ess-org-demo-results-html"
           :with-toc nil
           :base-directory "./artefacts"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org-demo-results.org")
           :publishing-function org-html-publish-to-html)
          ("ess-org-demo-results-pdf"
           :with-toc nil
           :base-directory "./artefacts"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org-demo-results.org")
           :publishing-function org-latex-publish-to-pdf)
          ("ess-org-beamer-html"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org-beamer.org")
           :publishing-function org-html-publish-to-html)
          ("ess-org-beamer-pdf"
           :with-toc nil
           :base-directory "./"
           :publishing-directory "./artefacts"
           :exclude ".*"
           :include ("ess-org-beamer.org")
           :publishing-function org-beamer-publish-to-pdf)
          ("ess-org" :components ("ess-org-html"
                                  "ess-org-pdf"
                                  "ess-org-demo-results-html"
                                  "ess-org-demo-results-pdf"
                                  "ess-org-beamer-html"
                                  "ess-org-beamer-pdf"))))
#+end_src

#+begin_src elisp
(provide 'el-org)
#+end_src

** testing :noexport:
            :PROPERTIES:
            :header-args:     :tanglex foobar
            :END:

#+begin_src R
23
#+end_src

*** else

#+begin_src R :tanglex hoobar
a+22
#+end_src

** ggm-twbs
this is the twbs code, with some of mine in front to re-arrange the
(normally exported) .html file into the right shape for twbs'
bootstrap'ping.

NB: as currently written, a =#+title= line -- which produces an =<h1>=
right at the beginning, messes up the logic.

(this code came from my photoTagger project.)

***** javascript
#+begin_src js :tangle ./tangled/ggm-twbs.js
  $(function() {
      'use strict';

      // begin ggm-twbs: this code beats the exported .html file into
      // twbs-shape

      $('#content').addClass("container");

      // here we are assuming the first child is the table of contents.
      // XXX if there is no toc?  XXX if it elsewhere in the .html file?
      $("#table-of-contents")
          .children()
          .first()
          .remove();
      $("#table-of-contents")
          .children()
          .wrapAll('<div class="col-md-3 col-md-push-9"></div>');
      $("#table-of-contents")
          .children()
          .unwrap();
      $("#table-of-contents").remove();

      // fixed olsun
      $('#text-table-of-contents').addClass("bs-docs-sidebar");

      // for scrollspy (below), add class nav to the toc
      $("#text-table-of-contents ul").addClass("nav");

      // then, *each* (not *all*, though maybe that is what we should
      // do?) of the rest are wrapped in the col-md-9/col-md-pull-3
      // div's
      $("#content").children()
          .first()
          .siblings()
          .wrapAll('<div class="col-md-9 col-md-pull-3"></div>');

      $('#content').children().wrapAll('<div class="row">');
      // end ggm-twbs


      $('.bs-docs-sidebar li').first().addClass('active');

      $(document.body).scrollspy({target: '.bs-docs-sidebar'});

      $('.bs-docs-sidebar').affix();
  });

#+end_src

***** css
my mods to twbs to allow exporting with normal org-mode html exporter,
then (in javascript, on the client) adapt the generated html to twbs,
need (well...) an external .css file.  these are pretty much direct
from a .html file twbs-exported from a .org file.
#+begin_src css :tangle ./tangled/ggm-twbs.css
  /* org mode styles on top of twbs */

  html {
      position: relative;
      min-height: 100%;
  }

  body {
      font-size: 18px;
      margin-bottom: 105px;
  }

  footer {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 101px;
      background-color: #f5f5f5;
  }

  footer > div {
      padding: 10px;
  }

  footer p {
      margin: 0 0 5px;
      text-align: center;
      font-size: 16px;
  }

  #table-of-contents {
      margin-top: 20px;
      margin-bottom: 20px;
  }

  blockquote p {
      font-size: 18px;
  }

  pre {
      font-size: 16px;
  }

  .footpara {
      display: inline-block;
  }

  figcaption {
      font-size: 16px;
      color: #666;
      font-style: italic;
      padding-bottom: 15px;
  }

  /* from twbs docs */

  .bs-docs-sidebar.affix {
      position: static;
  }
  @media (min-width: 768px) {
      .bs-docs-sidebar {
          padding-left: 20px;
      }
  }

  /* All levels of nav */
  .bs-docs-sidebar .nav > li > a {
      display: block;
      padding: 4px 20px;
      font-size: 14px;
      font-weight: 500;
      color: #999;
  }
  .bs-docs-sidebar .nav > li > a:hover,
  .bs-docs-sidebar .nav > li > a:focus {
      padding-left: 19px;
      color: #A1283B;
      text-decoration: none;
      background-color: transparent;
      border-left: 1px solid #A1283B;
  }
  .bs-docs-sidebar .nav > .active > a,
  .bs-docs-sidebar .nav > .active:hover > a,
  .bs-docs-sidebar .nav > .active:focus > a {
      padding-left: 18px;
      font-weight: bold;
      color: #A1283B;
      background-color: transparent;
      border-left: 2px solid #A1283B;
  }

  /* Nav: second level (shown on .active) */
  .bs-docs-sidebar .nav .nav {
      display: none; /* Hide by default, but at >768px, show it */
      padding-bottom: 10px;
  }
  .bs-docs-sidebar .nav .nav > li > a {
      padding-top: 1px;
      padding-bottom: 1px;
      padding-left: 30px;
      font-size: 12px;
      font-weight: normal;
  }
  .bs-docs-sidebar .nav .nav > li > a:hover,
  .bs-docs-sidebar .nav .nav > li > a:focus {
      padding-left: 29px;
  }
  .bs-docs-sidebar .nav .nav > .active > a,
  .bs-docs-sidebar .nav .nav > .active:hover > a,
  .bs-docs-sidebar .nav .nav > .active:focus > a {
      padding-left: 28px;
      font-weight: 500;
  }

  /* Nav: third level (shown on .active) */
  .bs-docs-sidebar .nav .nav .nav {
      padding-bottom: 10px;
  }
  .bs-docs-sidebar .nav .nav .nav > li > a {
      padding-top: 1px;
      padding-bottom: 1px;
      padding-left: 40px;
      font-size: 12px;
      font-weight: normal;
  }
  .bs-docs-sidebar .nav .nav .nav > li > a:hover,
  .bs-docs-sidebar .nav .nav .nav > li > a:focus {
      padding-left: 39px;
  }
  .bs-docs-sidebar .nav .nav .nav > .active > a,
  .bs-docs-sidebar .nav .nav .nav > .active:hover > a,
  .bs-docs-sidebar .nav .nav .nav > .active:focus > a {
      padding-left: 38px;
      font-weight: 500;
  }

  /* Show and affix the side nav when space allows it */
  @media (min-width: 992px) {
      .bs-docs-sidebar .nav > .active > ul {
          display: block;
      }
      /* Widen the fixed sidebar */
      .bs-docs-sidebar.affix,
      .bs-docs-sidebar.affix-bottom {
          width: 213px;
      }
      .bs-docs-sidebar.affix {
          position: fixed; /* Undo the static from mobile first approach */
          top: 20px;
      }
      .bs-docs-sidebar.affix-bottom {
          position: absolute; /* Undo the static from mobile first approach */
      }
      .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
          margin-top: 0;
          margin-bottom: 0
      }
  }
  @media (min-width: 1200px) {
      /* Widen the fixed sidebar again */
      .bs-docs-sidebar.affix-bottom,
      .bs-docs-sidebar.affix {
          width: 263px;
      }
  }

#+end_src

and, this is html to enable ggm-twbs:
#+begin_src html :tangle ./tangled/ggm-twbs.html-fragment
  <link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <link href="./ggm-twbs.css" rel="stylesheet"/>
  <script src="./ggm-twbs.js"></script>
#+end_src
