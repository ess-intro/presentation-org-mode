* set up Org Mode (one time)

** emacs, org mode setup :noexport:

to allow evaluating R code, evaluate this source block by putting
point inside and typing [C-c C-c] (control C followed by control C)
and giving permission for it to be evaluated.
#+name: set-allowed-languages
#+begin_src elisp :results none
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t) (R . t)))
#+end_src
(normally, you would do this by customizing
=org-babel-load-languages=.)

then, to allow *editing* R code, evaluate this source block, etc.
#+name: requireessrmode
#+begin_src elisp :results none
  (require 'ess-r-mode)
#+end_src

** first R source block -- lookup something

let's evaluate this

#+begin_src R
  state.abb[match("Wyoming", state.name)]
  lookup <- function(state, where) {
    where[match(state, where)] # XXX
  }

  lookup("Wyoming", state.abb)
#+end_src

we seem a bit low on results.  what's wrong?

** second source block -- find some state statistics

#+begin_src R
    state.x77[,"HS Grad"][match("Wyoming", state.name)]
#+end_src

** third re-do second source block

maybe we could re-use the lookup function?  using noweb?

#+name: lookup
#+begin_src R
  lookup <- function(state, where) {
    where[match(state, state.name)]
  }
#+end_src

okay, now we can include it with noweb

#+begin_src R
  <<lookup>>

  lookup("Wyoming", state.x77[,"HS Grad"])

#+end_src

** fourth: now, do a graph, state density versus life expectancy

for this, we're going to be accessing various state statistics, so we
realize we'd like *also* to have the lookup of state statistics as a
common routine.

*** fifth:

so, re-do the above code a bit...

#+name: state_stat
#+begin_src R :results none
  state_stat <- function(which) {
    state.x77[,which]
  }
#+end_src

and, make use of that, see if it works.

#+begin_src R :noweb yes
  <<state_stat>>
  <<lookup>>

  lookup("Wyoming", state_stat("HS Grad"))

#+end_src

*** sixth: some routines to compute the specific stats we want

now, what is the density?  =population=/=area=, i guess.  let's
compute.  in a separate code block, and use its *output*, via a =:var=
header argument, to pass the results to our graphing code below.  note
that =:results= is set to =table=.  (adding =drawer= means we can hide
it away easier, to keep the visual buffer less cluttered.)

also, we'll write (below) a routine to access the life expectancies.

#+name: density
#+begin_src R :results table drawer :noweb yes
  <<state_stat>>
  state_stat("Population") %/% state_stat("Area") # XXX
#+end_src


#+name: expectancy
#+begin_src R :results table drawer :noweb yes
  <<state_stat>>
  state_stat("Life Exp")
#+end_src

*** seventh, the graphing code itself.

and, now, write the graph routine.  i hope it works!  notice that we
aren't accessing =density= and =expectancy= via =:noweb=, but, rather,
via =:var=.

#+header: :var density=density expectancy=expectancy :session R
#+begin_src R :file expect.png :results output file graphics :exports both :noweb yes
  <<state_stat>> # note: syntax checker doesn't understand =noweb= references
  <<lookup>>

  density <- density[,1]
  expectancy <- expectancy[,1]
  plot(density, expectancy,
       panel.first = lines(stats::lowess(density, expectancy), lty = "dashed"),
       pch = ".", cex = 1.2, col = "blue")
  text(density, expectancy,  lookup(rownames(state.x77), state.abb),
       pos=1, cex=1, col="red")
#+end_src
