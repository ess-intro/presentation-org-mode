# (if all you see is the next line, ending in =...=, then the buffer is
# "folded"; to see the rest of the put your cursor at the beginning of
# the next line and type [TAB] twice.

* A file showing off some Org Mode and ESS features
** meta : setup                                                    :noexport:

This section helps set up this file, and is not part of the tutorial.
You can easily skip this section by typing [C-c C-n] ("control-c
control-n").

#+author: Greg Minshall
# can't do this because of ggm-twbs: #+title: using ESS with Emacs Org Mode
#+subtitle: [[https://ess-intro.github.io/][part of the ESS intro series]]
#+property: header-args :noweb yes
#+property: header-args:org :exports both
#+options: num:0 toc:3
# in this document, i sometimes need sub-, super-scripts, sometimes
# just a caret
#+options: ^:{}
#+property: header-args :noweb yes :exports code :eval never-export :unnumbered non-nil
# floating TOC:
# https://stackoverflow.com/questions/12232675/how-to-make-table-of-contents-floating
# trick of setupfile trick: https://stackoverflow.com/a/56407596/1527747
#+SETUPFILE: ./artefacts/ess-org-startup.org
#+HTML_HEAD:   <style>td.org-right, th.org-right, td.org-left, th.org-left { padding-left: 1em; padding-right: 1em;}</style>
# get our styles
#+HTML_HEAD:   <link href="./ess-org-demo-results.css" rel="stylesheet"/>
# LaTeX settings
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [36pt]
# LaTeX [[https://www.ctan.org/pkg/geometry]["geometry" package]], for setting page layout geometry. 
# "showframe" option is nice for debugging.
#+LATEX_HEADER: \usepackage[a4paper, width=.7\paperwidth, height=.8\paperheight]{geometry}

#+property: header-args :exports both

These are macros for consistency in writing Emacs key sequences with
corresponding command names.  If you are looking at the version of
this file pulled down from the web in ./artefacts, this file is
produced from a file ess-org-demo.org by replacing these macros so
that you, in the text, will actually see the key strokes.  (You can
look in Makefile to see how this happens.)

#+macro: C-cC-c =[M-x org-babel-execute-src-block]= (=[C-c C-c]=)
#+macro: C-cC-e =M-x org-export-dispatch= (=[C-c C-e]=)
#+macro: C-cC-vt =[M-x org-babel-tangle]= (=[C-c C-v t]=)
#+macro: C-capostrophe =[M-x org-edit-src-code]= (=[C-c ']=)
The following is true in a source edit buffer
#+macro: sb-C-capostrophe =[M-x org-edit-src-exit]= (=[C-c ']=)
#+macro: C-xC-s =[M-x org-edit-src-save]= (=[C-x C-s]=)
#+macro: C-cC-k =[M-x org-edit-src-abort]= (=[C-c C-k]=)
#+macro: C-cC-b =[M-x ess-eval-buffer]= (=[C-c C-b]=)
#+macro: C-xb =[M-x switch-to-buffer]= (=[C-x b]=)
#+macro: C-hf =[M-x describe-function]= (=[C-h f]=)
#+macro: C-cC-comma =[M-x org-insert-structure-template]= (=[C-c C-,]=)
these are standalone.  no macro (currently)
: =[M-x package-list-packages]=

** Preamble

*** Tips for using this document

#+begin_quote
If you are looking at this on the web, and I hope you find it useful.
But, a useful method of using this file to learn is to download [[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-demo-expanded.org][ the
plain text .org file]], open it in Emacs, and explore it, editing and/or
evaluating the various blocks provided, seeing what they do, changing
things, trying again, how did it change -- all those pedagogical
techniques.  (If you somehow mess up, you can always download the file
again!)
#+end_quote

The structure of this document was originally designed to (and may
still) parallel that of the short [[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-beamer.pdf][beamer presentation]] from the same
project.  There are pointers to other presentations and tutorials
under [[moreinfo][below]].  In particular, you may find the Org Mode [[https://orgmode.org/quickstart.html][Quick Start]]
guide, as well as a tutorial by Erik Iverson, [[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][org-mode-R-tutorial.org]],
and a more recent one from Vikas Rawal, [[https://github.com/vikasrawal/orgpaper/blob/master/orgpapers.org][orgpapers.org]], useful.

*** Some notation

#+begin_quote
A string inside square brackets, =[abecde]=, means you, the user,
should type the string, leaving out the square brackets.

Also, the Emacs convention for control and modifier (alt) keys is
used.  So, =[C-x b]= means type =control x=, then the letter =b=.
And, =[M-x b]= would mean type =modifier x= (maybe better known as
'alt x'), then the letter =b= (almost certainly an error!).
#+end_quote

*** Contents

Here's a brief map.  After a brief introduction to [[orgmode][Org Mode]], we
discuss
- [[srcblocks][the basics of]] source blocks, in which code is embedded;
- [[evaluating][how to /evaluate/]] a source block (to produce results);
- [[exporting][how to export]] a .org file, including the code of source blocks
  and/or the results of evaluating them;
- [[tangling][how to extract]] source blocks from the .org file and write them to a
  file (a process known as /tangling/);
- [[editing][the two options for editing]] source blocks;
- [[headerarguments][some of the /header arguments/]] that can be used; and, finally
- [[moreinfo][pointers to]] more information

** <<orgmode>> Introduction to Org Mode

[[https://www.gnu.org/software/emacs/][Emacs]] ([[https://en.wikipedia.org/wiki/Emacs][wikipedia]]) [[https://orgmode.org/][Org Mode]] [fn::a.k.a., "org-mode", Org Mode, orgmode
-- the proliferation of notation makes googling somewhat of a
challenge.]  sometimes exhorts one to do something like "Organize Your
Life In Plain Text!"; the Org Mode manual, on the other hand, starts
off by saying, "Org is an outliner".  The philosophy of Org Mode
(indeed, of Emacs, and maybe, to some extent, of any of the *nix
operating systems) is that using non-proprietary file formats and
software provides the most "liberating" and "horizon-free" way of
taking advantage of modern information technology.  And, to some
extent, that a mostly-command line interface, rather than a graphical
user interface, is also "the way to go".

I think Org Mode started off as a way of simplifying the creation of
formatted documents, with tables, etc., for taking notes, creating
agendas (items with date elements), and evolved into a much larger
system of utilities for, for example, converting ("exporting", in org
mode parlance) between the Org Mode syntax to .html, .pdf, etc.,
documents, with good support for doing mathematical (LaTeX)
formatting.

Org Mode does a good job exporting to LaTeX, html.  (Some people
primarily use Org Mode as a more "user friendly" interface to LaTeX,
though for serious documents, in the final analysis they probably
spend a lot of time tweaking LaTeX, and org-to-LaTeX, configuration.)

Though I have used Org Mode for more than a decade, I know very little
of most of its capabilities, as I mostly use it to centralize the
source code within a project, as well as to produce the random
document, especially documents with embedded code segments (known, in
Org Mode, as "source blocks").

Org Mode is bundled into the main Emacs distribution, but a
more-than-casual user might like to use the more-than-likely
up-to-date package available via [[https://melpa.org/][melpa]] (=[M-x package-list-packages]=,
and regexp-search for /^..org /).

[[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel]] is one name for talking about programming language support in
Org Mode.  You are able to embed source code inside of Org Mode
buffers, edit these code blocks in a language-specific way, evaluate
code blocks, pass the results of the evaulation of one code block to
another code block, and include code blocks and/or the results of
their evaulation in the document produced by exporting the org buffer.
The rest of this document is dedicated to explaining these things.

*** Blocks of various sizes, shapes, colors

Various sorts of "blocks" are supported in Org Mode files.  These
start with =#+begin_...=, and end with a corresponding =#+end_...=,
where the =...= are something like =src=, =example=, =quote=.  A
skeleton for some of these can conveniently be created with the
command {{{C-cC-comma}}}, and entering the type of block you are
interested in creating, e.g.,
- =e= for an example block (line wrapping does not apply) (=#+begin_example=)
- =q= for a quote block (line wrapping applies) (=#+begin_quote=)
- =s= for a source block (=#+begin_src=)

there are various other blocks; you can experiment by typing
{{{C-cC-comma}}} and then one of the following
- =a=
- =c=
- =C=
- =E=
- =h=
- =l=
- =v=
and seeing what you get, looking in the manual for enlightenment.  (Of
course, one can always search the manual for =#[+]begin_=.)
  
In addition to the source blocks mentioned above (and elaborated on
below), Org Mode allows short bits of "verbatim" code to be introduced
by a colon as the first non-blank column of a line
#+BEGIN_SRC org
  : this is verbatim
#+END_SRC

One can have longer runs of verbatim ("example") data (which is not
word wrapped, etc.:

# put point in the next src block and type [C-c '] for best viewing;
# type [C-c '] again to exit.
#+begin_src org
  ,#+name: ex
  ,#+begin_example
  this is a block
  that
  holds more verbatim text
  ,#+end_example
#+end_src
As well as longer bits of text that *will* be wrapped ("quote"):

# put point in the next src block and type [C-c '] for best viewing;
# type [C-c '] again to exit.
#+begin_src org
  ,#+begin_quote
  this is a bit of
  text that should
  show up, eventually, strung out in a smaller
  number
  of
  lines when "filled"
  (e.g., [M-x org-fill-paragraph] ([M-q]))
  ,#+end_quote
#+end_src

Blocks can optionally have names.  These names can be used as =:noweb=
references, or to use the value of a block (or, if a source block, of
the block's results) as input (a =:var=) to another block in the
file.[fn::I believe there are facilities for "naming" bits of
information in other .org files, but I don't know the details and I
don't know if it works with source code blocks.]

*** Drawers, Properties, Property Drawers

Org Mode [[https://orgmode.org/manual/Drawers.html#Drawers][drawers]] are a way of "closing away" information you normally
won't want to see.  These start with a line =:NAME:=, where =NAME= is
a string, and end with a simple(r) =:end:=.

A [[https://orgmode.org/manual/Properties-and-Columns.html#Properties-and-Columns][property]] allows you to associate values with keys.  Of particular
interest to us here are [[https://orgmode.org/manual/Property-Syntax.html#Property-Syntax][property drawers]], which combine the two
concepts to provide a place to put parameters that customize the
environment in which Org Mode processes your file (and, in particular,
for our case, the context in which source code is evaluated).

<<pastintro>>
** <<srcblocks>> Source blocks

Source blocks are lines of text, surrounded by a =#+begin_src= line
before the beginning and a =#+end_src= line after the end of the code.

Source blocks can be named by a =#+name= line which appears
immediately before the =#+begin_src= line.

Source blocks can also have various [[headerarguments][/header arguments/]] that modify the
context in which the source block executes.

(As mentioned above, a source block skeleton can be created by typing
{{{C-cC-comma}}} and entering [=s=].)

*** Inline source blocks

Source blocks can also be expressed using a =src_LANG= construct; a
=#+name:= line can be used to name the =src_LANG= block.  for example,
src_R{"hello, world"}.

Inline source blocks have their own syntax for [[headerarguments][header arguments]]:
src_R[:results output]{cat("hello, again")}.

And, the results of an inline source block can be used as input (via
[[var][:var]]) to another source block.

#+name: whyo
src_R{"42"} {{{results(=42=)}}}

#+begin_src R :var x=whyo :exports results
x
#+end_src

#+RESULTS:
| 42 |
|    |

** <<evaluating>> /Evaluating/ source blocks

In order to enable evaluation of source blocks of R code, you will
need to evaluate the following source block.  (Emacs lisp is the only
language whose evaluation is enabled by default.)  To do this,
position your cursor inside the source block (or on the =#+begin_src=
or =#+end_src= line), and type {{{C-cC-c}}} (not the square brackets;
just what is inside).  Additionally, evaluating code in a file can be
a security risk, so you will be prompted to make sure you want to
execute the code.

#+name: set-allowed-languages
#+begin_src elisp :results none
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t) (R . t) (python . t)))
#+end_src

(Here, I named the source block mainly so that the confirmation
message can provide you the name of the block for which it is asking
permission to evaluate.)

You can also enable evaluation in an R source code block by
customizing the variable =org-babel-load-languages=, via =[M-x
customize-variable]=, or =[M-S-:(customize-variable
'org-babel-load-languages)]= and enable R (something like "Ins",
"Value Menu", "R", "State"),

Once enabled, an R source block, for example, can be evaluated using
the same command, {{{C-cC-c}}} (with point inside the source block):

#+name: first-r-block
#+begin_src R :results output
  cat("this block has been evaluated\n")
#+end_src

*** Evaluation via a =call= statement

Source blocks can also be evaluated by =call= statements in the .org
file.  Call statements have two forms, somewhat similar to the two
forms of source blocks.

First, a =#+call= line can trigger evaluation of a source block.  To
trigger the triggering, you will need to type {{{C-cC-c}}} with point
positioned on the call line.

#+call: first-r-block()

Similarly, there is an inline call statement form which can trigger
evaluation of a source block.  here it is, inline!
call_first-r-block().

inline call statements have a syntax for block-specific header
arguments similar to that of inline source blocks.

** <<exporting>> /Exporting/ source blocks

Source blocks are, optionally, exported -- to a .html or .pdf file,
say -- along with some of the rest of a .org file.

To start the export process, one types executes the command
{{{C-cC-e}}}.  Org mode then pops up a window that allows you to
customize your export.  At the top of this window are mostly options
for defining the scope of the export.  For example, if you then type
=[C-s]=, only the subtree in which the export is initialized will be
exported.

Then, one can choose the type of export: Org, Html, Latex (including
PDF), Markdown, or Plain Text.

(The top and the lower parts talk about /publishing/, which
accomplishes exporting in a slightly heavier way, requiring the
parameters to be pre-set in the =org-publish-project-alist= variable.
We won't discuss publishing here -- you can read about it in the Org
Mode manual -- but it is, in fact, the way the .html and .pdf files
associated with this tutorial have been produced.)

The following code is based on a [[https://stat.ethz.ch/pipermail/r-help/2021-March/470671.html][question]] to the R-help e-mail list.
The goal was a simple way to find the peaks and valleys (highest and
lowest values) in a vector of numbers.
#+name: peaks-and-valleys
#+begin_src R :exports both
  x <- c(1,0,0,0,2,2,3,4,0,1,1,0,5,5,5,0,1)
  (cumsum(rle(x)$lengths)-(rle(x)$length-1))[which(diff(diff(rle(x)$values)>=0)<0)+1]
  cumsum(rle(x)$lengths)[which(diff(diff(rle(x)$value)>0)>0)+1]
#+end_src

If you type {{{C-cC-e}}}, then [C-s] (for "subtree"), then [h] (for
"html"), and [o] (for "open"), then, assuming your Emacs is configured
to know how to open a .html file in a browser (90% likely, I'd guess),
you'll see the text in this subtree, the above code, and the indices
of the valleys (the last result).

The =:exports both= is a header argument that tells Org Mode to export
both the source code itself, as well as the results of its evaluation
(you will be prompted to authorize the evaluation).  One could also
say one of: =:exports none=, =:exports code=, or =:exports results=.

** <<tangling>> /Tangling/ code

Tangling is a term the [[https://orgmode.org/worg/org-contrib/babel/index.html][literate programming]] world uses to mean
extracting the source code from a "literate" document in a way that
the code can then be compiled and/or executed.  In Org Mode files, the
=:tangle= header argument defines the filename to which a source block
should be written.  Like all header arguments, the =:tangle= header
argument can be specified at the file, subtree, or individual source
block level.  All source blocks that have (or inherit) the same
=:tangle= header argument will be tangled to the same file, in the
order in which they appear in the .org file.

Repeating a source block from above (using [[noweb][=:noweb=]] syntax),

#+name: peaks-and-valleys-tangling
#+begin_src R :exports both :tangle peaks-and-valleys.el :noweb yes
  <<peaks-and-valleys>>
#+end_src

Now, you could, if you chose, enter {{{C-cC-vt}}}.  But, be warned!
This will tangle all the source blocks in the current (this) .org file
that have a =:tangle= header argument (specified or inherited).  One
can restrict the tangle operation to the source block at point (see
{{{C-hf}}} for =org-babel-tangle= for details), but even so, I would
suggest being careful.

** <<editing>> /Editing/ a source block

The source block is just a number of text lines in text file.  So, it
is very normal to do minor edits in line, in the .org file.  A certain
amount of /code highlighting/ (/fontification/, I guess, in Emacs
parlance) is provided when editing source blocks inline.

On the other hand, by positioning the cursor on the source block and
executing {{{C-capostrophe}}}, one can "pop out" the
source block and edit it in a buffer with the major mode set
appropriately for the language of the source block.  In the case of an
R source block, the major mode will (the R-flavor of) ESS, =ESS[R]=.

Feel free to experiment with the following code.  On the R-help list,
a new value for the vector =x= was proposed.
: x <- c(1,1,1,2,2,3,4,4,4,5,6,6,6)
If you like, edit the source, change =x=, and evaluate it.  What is
its result?  Is there a peak?  A valley? [fn::One solution was proposed
[[https://stat.ethz.ch/pipermail/r-help/2021-March/470709.html][here]].]

#+begin_src R
  x <- c(1,0,0,0,2,2,3,4,0,1,1,0,5,5,5,0,1)
  (cumsum(rle(x)$lengths)-(rle(x)$length-1))[which(diff(diff(rle(x)$values)>=0)<0)+1]
  cumsum(rle(x)$lengths)[which(diff(diff(rle(x)$value)>0)>0)+1]
#+end_src

<<orgsrcminormode>> When editing, the "OrgSrc" minor mode is enabled.
This mode provides binding for
- {{{C-xC-s}}} :: to save the source edit back to the main .org buffer
- {{{C-cC-k}}} :: to abort the current editing, discarding any
  unsaved changes
- {{{sb-C-capostrophe}}} :: to save any unsaved changes back to the
  .org buffer and close the source edit buffer

NB: If you are editing a block that has [[noweb][:noweb]] references, the
references will *not* be expanded when passing the block (in part or
in whole) to a running iESS instance (via, e.g., {{{C-cC-c}}} or
{{{C-cC-b}}}).  And, in fact, the R interpreter will likely flag a
syntax error should you try to do so.

** <<headerarguments>> Header arguments

Header arguments modify the execution context in which Org Mode source
blocks are evaluated and/or in which the results of those evaluations
are processed.

<<perfile>> Header arguments can be specified on, and apply to
- a =#+property: header-args= line, to apply as defaults for all
  source blocks in a file
- inside a =:PROPERTIES:= drawer of a headline (node in the tree
  defined by the .org file), to apply as defaults for all source
  blocks in that subtree
- the =#+begin_src= line that precedes the source block
- separate =#+header= line(s), immediately preceding the =#+begin_src=
  line.

Here is an example from a .org file that shows those ways of defining
various header arguments.  The =#+header-args+= construct adds these
arguments to the list of header args.

# put point in the next src block and type [C-c '] for best viewing;
# type [C-c '] again to exit.
#+BEGIN_SRC org
  ,#+property: header-args :tangle ./nosuchdirectory/bigfile

  ,** this is somewhere in this file
       :PROPERTIES:
       :header-args+: :tangle very/important/code.R
       :END:

  now, code blocks will carry that name

  ,#+header: :exports results
  ,#+begin_src R :results value
      x <- "we want some code, and we want it now!"
  ,#+end_src
#+END_SRC

The following are some of the header arguments I most often use.

*** <<colnames>> =:colnames and :rownames=

When processing a table result of a previous source block to be used
as an input [[var][variable]] to another code block, the =:colnames= header
argument instructs Org Mode how to interpret the first row: should it
be assumed to be a row of column names, a row of data, or should Org
Mode use a heuristic to make that determination.

Similarly, Org Mode uses =:rownames= to determine whether the first
column of each row should be considered as a name for that row, or
simply as the data of the first column of that row.

Also, when processing the *results* of a code block, these header
arguments tell some Org Mode language support routines how to deal
with column and row names of the returned result.  If left off, the
Org Mode result of evaluation will drop any language-specific column
and row names.  However, if these header arguments are set to =yes=,
language-specific column and row names will be included in the results
placed in the Org Mode buffer.

#+BEGIN_SRC R
mtcars[1:3,]
#+END_SRC

#+RESULTS:
|   21 | 6 | 160 | 110 |  3.9 |  2.62 | 16.46 | 0 | 1 | 4 | 4 |
|   21 | 6 | 160 | 110 |  3.9 | 2.875 | 17.02 | 0 | 1 | 4 | 4 |
| 22.8 | 4 | 108 |  93 | 3.85 |  2.32 | 18.61 | 1 | 1 | 4 | 1 |

#+begin_src R :colnames yes :rownames yes
mtcars[1:3,]
#+end_src

*** <<noweb>> =:noweb=

Many (most?) programming languages have a way of "including" the
"textual" contents of one source file in the compilation or execution
phase of another source file.  I think of =#include <stdio.h=, for
example, in =C=.  Literate programming defines a way of doing this
known as [[https://www.cs.tufts.edu/~nr/noweb/]["noweb"]].

In Org Mode's [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming-example][implementation]], inside a source block, a _reference_ to
a previous block of code named =NAME= is denoted by =<<NAME>>=.  The
double angle brackets signal that this is a noweb
reference.[fn::Outside of a source block, =<<NAME>>= is used to tag an
[[https://orgmode.org/manual/Internal-Links.html#Internal-Links][internal link]] in the .org file; if you are visiting this as a .org
file in Emacs, you may have noticed instances in this document.]
However, by default, noweb processing is *disabled* in an Org Mode
buffer.  The =:noweb= header argument defaults to =no=, but can be set
to =yes= to enable noweb processing.  Again, [[perfile][as with all header
arguments]], this can be done on a per-file, per-subtree, or
per-(referring-)source block basis.

The noweb reference =<<NAME>>= can refer to either the name of another
source block in the .org file:
#+name: a-noweb-name
#+begin_src R :noweb no
  cm <- "copy me!"
#+end_src

or with the =:noweb-ref= header argument:
#+begin_src R :noweb-ref another-noweb-name :noweb no
  cmt <- "copy me, too!"
#+end_src

#+begin_src R :noweb yes :results output
  <<a-noweb-name>>
  <<another-noweb-name>>
  cat(cm, "\n", cmt, "\n", sep="")
#+end_src

(If you edit the header of the previous source block by changing "yes"
to "no" and then evaluate it, you will get an error as R tries to
parse a line that begins with =<<=.)

Note that, like the =:noweb= header argument, the =:noweb-ref= header
argument can be set on a subtree basis.  (I dread to think of what
would happen were it to be set on a file basis.  Okay, I have to try.
Be right back...  Not much happened.  I suppose this is
special-cased.)

*** <<var>> =:var=

In Org Mode, the evaluation of source blocks can include initializing
variables, using the =:var= header argument.

#+name: gives-pi
#+begin_src R :var pi=3.14
  pi
#+end_src

The left hand side of the argument to =:var= is the name of the
variable as seen by the code inside the source block.  The right hand
side can be a constant (as above), or can designate the output of
another source block in the .org file.  In that case, the right hand
side is the name (=#+name:=) of the source block providing the desired
result.

If you evaluate the following source block, you will be asked to allow
evaluation *twice*: once to produce the result from the *above* source
block, and a second time to produce the result from the source block
you are evaluating.

#+begin_src R :var pitoo=gives-pi :session R :results output
  cat("you were", pitoo/pi, "close!\n")
#+end_src

The language of the source block providing the value of the variable
does same as the language of the source block receiving the value.  In
general, though, there may be some adaptation required to mould the
shape of the input value to that needed by the source code.

#+name: from-python
#+begin_src python :results value
  return 21
#+end_src

#+name: to-r
#+begin_src R :var howmany=from-python
  2*howmany
#+end_src

The name on the right hand side, instead of naming another source
block in the file, can also name, e.g., an Org Mode table.

#+name: a-table
| student | first exam | second exam | final |
|---------+------------+-------------+-------|
| Greg    |          1 |           3 |     2 |
| George  |          2 |           2 |     2 |
| Linda   |          3 |           1 |     2 |
| Georgia |          4 |           4 |     4 |

In the following code block, the [[colnames][:colnames]] header argument is set to
=yes= so that the first row is considered a row of column names.

#+begin_src R :var tbl=a-table :colnames yes :session R
  summary(tbl)
#+end_src

#+RESULTS:
| student          | first.exam   | second.exam  | final       |
|------------------+--------------+--------------+-------------|
| Length:4         | Min.   :1.00 | Min.   :1.00 | Min.   :2.0 |
| Class :character | 1st Qu.:1.75 | 1st Qu.:1.75 | 1st Qu.:2.0 |
| Mode  :character | Median :2.50 | Median :2.50 | Median :2.0 |
|                  | Mean   :2.50 | Mean   :2.50 | Mean   :2.5 |
|                  | 3rd Qu.:3.25 | 3rd Qu.:3.25 | 3rd Qu.:2.5 |
|                  | Max.   :4.00 | Max.   :4.00 | Max.   :4.0 |

For R code, a second effect of setting =:colnames= to =yes= is that if
the *result* is an R data frame, its column names (=colnames()=) will
be preserved in the resulting Org Mode table

#+begin_src R :colnames yes
  mtcars[1:4,]
#+end_src

#+RESULTS:
|  mpg | cyl | disp |  hp | drat |    wt |  qsec | vs | am | gear | carb |
|------+-----+------+-----+------+-------+-------+----+----+------+------|
|   21 |   6 |  160 | 110 |  3.9 |  2.62 | 16.46 |  0 |  1 |    4 |    4 |
|   21 |   6 |  160 | 110 |  3.9 | 2.875 | 17.02 |  0 |  1 |    4 |    4 |
| 22.8 |   4 |  108 |  93 | 3.85 |  2.32 | 18.61 |  1 |  1 |    4 |    1 |
| 21.4 |   6 |  258 | 110 | 3.08 | 3.215 | 19.44 |  1 |  0 |    3 |    1 |

#+begin_src R :colnames no
  mtcars[1:4,]
#+end_src

#+RESULTS:
|   21 | 6 | 160 | 110 |  3.9 |  2.62 | 16.46 | 0 | 1 | 4 | 4 |
|   21 | 6 | 160 | 110 |  3.9 | 2.875 | 17.02 | 0 | 1 | 4 | 4 |
| 22.8 | 4 | 108 |  93 | 3.85 |  2.32 | 18.61 | 1 | 1 | 4 | 1 |
| 21.4 | 6 | 258 | 110 | 3.08 | 3.215 | 19.44 | 1 | 0 | 3 | 1 |

*** =:results=
	:PROPERTIES:
    :header-args+: :noweb yes
    :END:

The =:results= header argument specifies many things.  First, it
specifies whether the results of an evaluation consist in the value
"returned" by the evaluated source block, or by the output (to
standard output) produced by the source block.  The "value returned"
means, in many programming languages (include R), the value of the
last statement executed in the source block.  You may have noticed
examples of this use of =:results= in some of the previous source
blocks.  The values here are =value= and =output=.

#+name: usenowebhere
#+begin_src R :results none
  truepi <- pi
  cat(truepi, "\n", sep="")
  invisible(truepi*2)
#+end_src

#+begin_src R :results output
  <<usenowebhere>>
#+end_src

#+RESULTS:
: 3.141593

#+begin_src R :results value
  <<usenowebhere>>
#+end_src

#+RESULTS:
: 6.28318530717959

**** Type of result

Here, the question is what sort of Org structure should the returned
value be considered to consist.  The results can be interpreted to be
an Org Mode table, list, or verbatim text.  Or, the results can be
output to a file.

#+name: results-noweb
#+begin_src R
  mtcars[c(1,12,13, 19),]
#+end_src

If no result type is listed, Org Mode makes its pretty-good guess.

#+begin_src R :results value
  <<results-noweb>>
#+end_src

But, to be sure, you can specify the type you would like.  (Note the
reapearance of =:colnames=.)
#+begin_src R :results value table :colnames yes
  <<results-noweb>>
#+end_src

=scalar= and =verbatim= are synonyms.  They cause the value to be
taken, well, at face value:
#+begin_src R :results scalar
  <<results-noweb>>
#+end_src

And, =list= converts the source block result into an Org Mode list.

#+begin_src R :results list
  <<results-noweb>>
#+end_src

**** How the results are formatted

There are various ways Org Mode might decide to format the results,
of, more or less, whatever type, before embedding them in the .org
buffer.

For example, to want the results to be wrapped in a source block, one
can specify =code=:

#+begin_src R :results value code
  "<<results-noweb>>"
#+end_src

#+RESULTS:
:results:
mtcars[c(1,12,13, 19),]
:end:

This also shows that =noweb= syntax isn't defeated by, e.g., being
embedded inside quotation marks.  One can also specify that the
results be embedded in an Org Mode "drawer" (which can be "closed", so
the results don't show), or embedded in a source block of type "org",
in blocks whose content will only be used when exporting to HTML, or
to LaTeX (including PDF), etc.

There is (apparently -- writing this tutorial is a learning
experience!) also a =:wrap= header argument, separate from the
=:results= header argument, which specifies a value =X=, and the
results are summarily wrapped in a =#+begin_X...#+end_X= block.

#+begin_src R :wrap foo
  3
#+end_src


**** Handling of results

Typically, the results of evaluating a source block are placed in the
buffer following the source block, preceded by a line
: #+RESULTS: <NAME>
where =<NAME>= is the name of the source block, if any, or blank.

#+begin_src R
  Sys.time()
#+end_src

#+RESULTS:
: 2021-03-31 09:01:47

#+name: time
#+begin_src R
  Sys.time()
#+end_src

#+RESULTS: time
: 2021-03-31 09:01:57

However, this behavior can be modified with the =:results= header
argument.  The relevant options are
- silent :: Don't change the buffer.  The results are echoed in the
  minibuffer.
- replace :: This is the normal behavior; the =#+RESULTS:= block is
  replaced.
- append :: Each evaluation generates a separate =#+RESULTS:= block,
  which is placed after the previous result blocks.
- prepend :: Each evaluation generates a separate results block, which
  is placed before all previous result blocks.

Well, really, that is all pretty much just copied from the [[https://orgmode.org/manual/Results-of-Evaluation.html#Results-of-Evaluation][manual]].
Which, see.

*** =:session=

Normally, when Org Mode evaluates a source block, in instantiates a
new *process* of the appropriate type (the =R= command, for example),
provides that process with the source from the source block (expanding
=:noweb= references), and lets it run.

This ensures that each run starts from a "clean state".  On the other
hand, it means that artefacts left behind by previous runs are not
available to a future run in cases where that might be desirable.
And, it can complicate debugging.

Thus, Org Mode provdies a =:session= header argument which names a
buffer (that Org Mode will create, if it doesn't already exist) in
which evaluations of the current source block (or, all source blocks
in the file, or all in a subtree) will occur.

During a given Emacs instance, the first time you type {{{C-cC-c}}} in
a source block with a given =:session= name, Emacs will prompt you for
the name of the starting directory (with a default being the directory
of the current file).  It will then start up such a process, attach it
to a buffer (i'm not totally sure of the Emacs terminology here) with
the name provided as the argument to the =:session= header argument
(or, use a language-specific default), and evaluate your code.  This
works for interpreted languages but not, to my knowledge, for compiled
languages.

#+begin_src R :session R-session-name :exports code :eval never-export :results none
x <- 1
#+end_src

#+begin_src R :session R-session-name :eval never-export :exports code
x
#+end_src

If you evaluate the above two blocks in order, the second will return
as a result the value of =x= set by the first.

After evaluations, you can use {{{C-xb}}} to switch to that buffer and
inspect the state, maybe set debug breakpoints, or debug after error
or debug statement (=browser()=, say) in your code.

For R, the session buffer uses ~ESS[R]~ mode.  (As well as in the
[[orgsrcminormode][OrgSrc]] minor mode.)

As I said above, the fact that future evaluations of the given source
block, or of any other source block with the same =:session= argument,
will run in the same R process is both a feature and a bug.  On the
bug side, you may end up developing code that only works with the
accumulated state in the current buffer.

For example, say you are developing an [[https://cran.r-project.org/web/packages/][R package]] and are testing it
with some code that imports (=require()=) that package.  And, say your
test code points out an error in your package code, and that you fix
your package code and re-build and re-install your package.  Now, if
you once again evaluate your test code, it will execute the
=require()= statement but will do nothing as, as far as R is
concerned, your package is *already* loaded.  So, you will need to
detach and unload your package which, if my memory serves me right
: detach(package:PACKAGENAME, unload=TRUE)
or some such.  *Then*, R will load the new version of your package the
next time you or your code =require's= it.

Still, I find =:session= immensely valuable while developing code or
doing an analysis.  If you find yourself wanting to use a debugger to
debug your code, or to incrementally build up state as your are
working, I recommend (carefully) using it.

*** =:cache=

Sometimes you will have a long-running computation, the results of
which are used as input to other computations, or for export.  In this
case, you may not want to have to re-run the computation if its
results won't change.  To help with this situation, Org Mode has the
=:cache= header argument.

If a source block is marked with =:cache yes= is scheduled to be
evaluated, Org Mode checks the following:
- the contents of the source block itself
- the header arguments to the source block
- the values of the sources of all the =:var= header arguments

If none of these have changed (as testified by a cryptographic hash
over these) since the last evaluation of the source block, then the
value of the previous evaluation is used as the value of the current
evaluation.

Of course, if a source code block takes input from some external
source, such as a file, that may have changed since the previous
evaluation, Org Mode won't notice, and you may get incorrect results.
Also, a source code block that makes use of the results of a random
number generator will not be re-evaluated.  It is the responsibility
of the programmer to *not* mark source blocks of these types with
=:cache yes=.

Here is an example.  When it is actually evaluated, this source code
block will block for two seconds.  If you evaluate it a *second* time,
the results will appear immediately.

#+name: long-computation
#+begin_src R :cache yes
  Sys.sleep(2)
  42
#+end_src

Now, we look at how =:cache= deals with one of the inputs changing.
First, here is a source which produces the same value each time it is
run:
#+name: stable
#+begin_src R
  23
#+end_src

Then, a source that produces a different value each second:
#+name: unstable
#+begin_src R
  Sys.time()
#+end_src

Then, two functions.  The first uses results of the unvarying source
code block as input.  The first time you evaluate it with
{{{C-cC-c}}}, it will sleep the two seconds.  However, after that,
evaluating it will return results immediately.
#+begin_src R :var input=stable :cache yes
  Sys.sleep(2)
  input
#+end_src

This function, on the other hand, takes as input results from the
varying function.  Each time (well, separated by at least one second)
you evaluate it, it will take the full two seconds.
#+begin_src R :var input=unstable :cache yes
  Sys.sleep(2)
  input
#+end_src

** <<moreinfo>> Other sources of information

The official [[https://orgmode.org/quickstart.html][Quick Start]] guide provides a very good introduction to
Org Mode.  The main [[https://orgmode.org/][Org Mode]] web page is another good source for
further information, as is the Org Mode [[https://orgmode.org/worg/][worg]] site.  (You may find it
useful to take a linear stroll through [[https://orgmode.org/worg/sitemap.html][the worg site map]].)  Also, once
installed on your system, the Org Mode info pages are available in
Emacs (or, using =info(1)=).

The Org Mode [[https://orgmode.org/guide/][Compact Guide]] has [[https://orgmode.org/guide/Working-with-Source-Code.html][a section]] on source blocks.  A separate
[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-R.html]["worg" page]] gives information on using R with Org Mode.  The list of
languages officially supported by Org Mode is documented [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][here]].  In
addition to that list, a number of Emacs [[https://www.emacswiki.org/emacs/InstallingPackages][packages]] add support for
additional programming languages; you can enter =[M-x list-packages]=
and (regexp) search for =^ ob-=, to list a number of these.

The Org Mode community has various [[https://orgmode.org/community.html][forms]] of engaging with one another.
In particular, there is an e-mail list, an IRC channel, etc.

The other presentations in this [[https://ess-intro.github.io/][ESS intro series]] provide more detail
about ESS.  The [[https://ess.r-project.org/index.php?Section=home][ESS project]] also has ways to connect, listed [[https://ess.r-project.org/index.php?Section=getting%20help][here]].

The beamer slides for this tutorial are [[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-beamer.pdf][here]] ([[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-beamer.html][html]]).  A .html version
of this file is [[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-demo-results.html][here]] ([[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-demo-results.pdf][pdf]]), and plain text version, suitable for
experimentation in Emacs, is [[https://ess-intro.github.io/presentation-org-mode/artefacts/ess-org-demo-expanded.org][here]] (no PDF file for this one!).  The
github repository for this presentation is [[https://github.com/ess-intro/presentation-org-mode][here]].

There are some videos you might find useful.  Rainer König's
[[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][screencasts]] about Org Mode (also available as a [[https://www.udemy.com/course/getting-yourself-organized-with-org-mode/?referralCode=D0CB0D077ED5EC0788F7][course on Udemy]]) are
useful for coming up to speed with Org Mode, but are more focused on
the non-programming aspects of Org Mode.  SystemCrafters' [[https://www.youtube.com/c/SystemCrafters/videos][videos]]
include a number that touch on various aspects of both Emacs and Org
Mode.  DT ("Distro Tube"?) has yet another [[https://www.youtube.com/watch?v=Ea_-TaEGa7Y][introductory video]].


There are some nice tutorials.  A somewhat older one is from Erik
Iverson, [[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][org-mode-R-tutorial.org]].  And, there is a more recent one
from Vikas Rawal, [[https://github.com/vikasrawal/orgpaper/blob/master/orgpapers.org][orgpapers.org]].

** more random :noexport:

[[https://orgmode.org/list/876229nrxf.fsf@gmail.com/]["new exporter"]] e-mail message

{{{C-cC-c}}}
